*usr_41.txt*	For Vim バージョン 7.1.  Last change: 2007 Apr 26

		     VIM USER MANUAL - by Bram Moolenaar

			      vimスクリプトの作り方


vimスクリプト言語は、起動時のvimrcファイル、シンタックスファイル、などなどで
使われています。本章では、vimスクリプトで使える命令などについて説明します。
説明することが大量にありますので、この章は長い目になっています。

|41.1|	はじめに
|41.2|	変数
|41.3|	式
|41.4|	条件
|41.5|	式の実行
|41.6|	関数を使う
|41.7|	関数を定義する
|41.8|	リストと辞書
|41.9|	例外
|41.10|	いろんな注釈
|41.11|	プラグインを書く
|41.12|	ファイルタイププラグインを書く
|41.13|	コンパイラプラグインを書く
|41.14|	高速に読み込まれるプラグインを書く
|41.15|	ライブラリスクリプトを書く
|41.16|	Vimスクリプトを配布する

     Next chapter: |usr_42.txt|  新たなメニューを作る
 Previous chapter: |usr_40.txt|  新たなコマンドを作る
Table of contents: |usr_toc.txt|

==============================================================================
*41.1*	はじめに				*vim-script-intro* *script*

一番最初に見るvimスクリプトはvimrc ファイルでしょう。vimは起動する時にこの
ファイルを読み込み、書いてあるコマンドを実行します。あなたの好みに合せて、
オプションの値を変えることができます。この中では":"コマンド（先頭が":"で
始まるようなコマンド。Exコマンドとかコマンドラインコマンドと呼ぶ時もあり
ます。）
シンタックスファイルもvimスクリプトです。これは特定のファイルタイプ用にオプ
ションを設定するためのファイルです。複雑なマクロを複数のvimスクリプトファイ
ルに分けて定義したりもできます。他にもいろんな使い方を考案できるでしょう。

まず、簡単な例から始めましょう。 >

	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
<
	Note:
	本当はここでは":"はいりません。vim内でコマンドを入力する場合にだけ
	必要です。vimスクリプトファイルでは、取り除いても構いません。
	ここでは、これらが":"コマンドであり、通常コマンドとは違っていること
	をハッキリさせるために使っています。
	Note:
	ここからテキストをヤンクして、:@"として実行することでこの例を試してみ
	ることができます。

この例の出力は次のようになります:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

1行目で":let"コマンドにより変数に値を代入しています。一般的な書式は次の通りで
す。 >

	:let {variable} = {expression}

この場合、変数名が"i"で、式が数字の１という単純な値です。
":while"コマンドはループの開始を示します。一般的な書式は次のとおりです。 >

	:while {condition}
	:  {statements}
	:endwhile

呼応する":endwhile"までの間にある命令はwhileの条件({condition})が True であ
る間、繰り返して実行します。ここでの条件は"i < 5"という式です。これは変数 i
が５よりも小さい間は True となります。
	Note:
	誤ってループが止まらなくなってしまったときは、CTRL-C (MS-Windowsでは
	CTRL-Break)を押すことで中断できます。

":echo"コマンドはパラメタの内容を表示します。ここでは"count is"という文字列
と変数 i の内容となります。i が１であれば、このような結果となります。

	count is 1 ~

ここにはさらに":let i += 1"というコマンドがあります。これは":let i = i + 1"と
同じことをします。変数 i の内容に１を加え、その値を同じ変数の新たな値として代
入します。

この例はコマンドの説明として出しましたが、実際にこういったループを書きたいとき
は、より簡潔に次のように書くことができます: >

	:for i in range(1, 4)
	:  echo "count is" i
	:endfor

|:for|と|range()|の説明はずっと先にあります。すぐに読みたい場合は、このリンク
をたどってください。


３種類の数字
-----------

数字には10進数、16進数、8進数のいずれかを指定できます。16進数は先頭が"0x"か
"0X"で始まります。例えば"0x1f"は10進数の31のことです。8進数は先頭が"0"で始まり
ます。例えば、"017"は10進数の15です。10進数のつもりで先頭に"0"を付けないように
注意してください。8進数として扱われてしまいます。
":echo"コマンドは常に10進数で出力を行います。このようになります。 >

	:echo 0x7f 036
<	127 30 ~

数値にはマイナス記号を付けると負数となります。負数は8進数や16進数でも使えま
す。マイナス記号は減算でも使います。この例を上の例と較べてください。 >

	:echo 0x7f -036
<	97 ~

式の途中にある空白は無視します。とはいっても項目のセパレータに空白を使うと、式
の可読性を高めることになりますのでお勧めします。例えば上の例で、負数であるかの
ような誤解を防ぐために、マイナス記号に続く数値の前には空白を置きましょう。 >

	:echo 0x7f - 036

==============================================================================
*41.2*	変数

変数名にはアルファベット、数字、アンダースコア(_)が使えます。ただし先頭に数
字は使えません。正しい変数名は例えば次のとおりです。

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

逆に間違った名前は次の通りです。
	foo+var		"+"は変数名に使えません。
	6var		先頭に数字は使えません。

これらはグローバル変数です。定義されている変数名の一覧を見るのはこのコマンド
です。 >

	:let

グローバル変数はどこでも使えます。あるスクリプトファイルで"count"という変数
を使っていれば、他のスクリプトでもその変数が使えるということです。これは少な
くとも混乱を招きますし、実際に問題が発生すれば最悪です。これを避けるために変
数がスクリプト内にローカルであるというマーク"s:"を付けることができます。
例えば、あるスクリプトに次のようなコードがあるとします。 >

	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count += 1
	:endwhile

"s:count"はスクリプト内にローカルですから、"other.vim"というスクリプトからは
この変数の内容を変更できません。もし"other.vim"も"s:count"変数を使っていたと
しても、それは"other.vim"の中でローカルな別の変数です。スクリプトローカルな
変数の詳細については|script-variable|をご覧ください。

変数には他にも多くの種類があります。|internal-variables|をご覧ください。中で
もよく使うものを掲げておきます。

	b:name		バッファローカルな変数
	w:name		ウィンドウローカルな変数
	g:name		グローバル変数(関数内でも利用可能)
	v:name		vimが事前に宣言している変数


変数の削除
----------

変数はメモリを占有していますので、":let"コマンドの出力にも現れます。変数を削
除するには":unlet"コマンドを使います。例えば、 >

	:unlet s:count

これはスクリプトローカルな変数"s:count"を削除して、占有していたメモリを開放
します。変数が存在しているかどうかわからないけれど、なくてもエラーにはしたく
ない場合には次のように ! を追記します。 >

	:unlet! s:count

スクリプトが終了すると使われなくなったローカル変数は自動的に削除されません。
次にそのスクリプトを実行した時には、前回の終了時の値を使えます。例えば次の
とおりです。 >

	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"

"exists()"関数は変数が既に定義されているかどうかをチェックします。パラメタに
は調べたい変数の名前を指定します。変数自身じゃありません。変数自身を調べるに
はこのようにします。 >

	:if !exists(s:call_count)

これで、s:callcountの内容がexists()関数でチェックすべき変数名となります。
ビックリマーク(exclamation mark)は値を反転します。変数がTrueの場合はFalseと
なり、Falseの場合はTrueになります。これを"not"と呼いんでも構いません。つまり
"if !exists()"は"if not exists()"とも読めるということです。
vimでは、０以外の値は全てTrueです。０はFalseです。
	Note:
	数値が期待される文脈においては、文字列は自動的に数値に変換されます。数
	字で始まらない文字列は０に変換されます。つまり、次の例を見てください: >
		:if "true"
<	"true"は０に変換されるので、Falseとなります。


文字列変数と定数
----------------

ここまでは、変数の値には数値だけを使ってきました。値には文字列も使えます。vim
で扱える基本型は数値と文字列です。 型は":let"コマンドで変数に値を代入する度に
動的に変化します。詳しくは|41.8|を参照してください。
変数に文字列値を代入するには文字列定数を使います。文字列定数には２つのタイプ
があります。１つ目はダブルクオート(")で囲った文字列です。 >

	:let name = "peter"
	:echo name
<	peter ~

文字列の中でダブルクオートを使いたければ、その直前にバックスラッシュを付け
ます。 >

	:let name = "\"peter\""
	:echo name
<	"peter" ~

文字列をシングルクオート(')で囲めば、バックスラッシュを省くことができます。 >

	:let name = '"peter"'
	:echo name
<	"peter" ~

シングルクオートで囲った場合、全ての文字は見た目の通りの意味となります。シング
ルクオートのみが特別な意味を持ちます。シングルクオート1つを出すには、2個連続さ
せます。バックスラッシュも見た目の通りに扱われるため、次の文字の特殊な意味を打
ち消すといった働きをしません。
ダブルクオートで囲った文字列には特殊な意味の文字が使えます。以下に便利なもの
を掲げておきます。

	\t		<Tab>
	\n		<NL>, line break
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

最後の２つは単なる例です。"\<name>"形式で(nameで指定した)特殊キーを含むとい
う意味になります。
文字列で使える特殊な表現についての詳細は|expr-quote|をご覧ください。

==============================================================================
*41.3*	式(expression)

vimには豊富ながらもシンプルな方法で式の処理を行えます。厳密な定義については
|expression-syntax|をご覧ください。ここではごく基本的な機能にしぼって説明し
ます。
既に述べたような、数値や文字列や変数はそれ自体が１つの式です。つまり式を書け
る場所であれば、数値でも文字列でも変数でも使えるということです。それ以外にも
式にはこのような基本アイテムがあります。

	$NAME		環境変数
	&name		オプション
	@r		レジスタ

例を挙げましょう。 >

	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5

"&name"形式はオプション値を保存したり、別の値に設定したり、古い値に戻したり、
といったことに使えます。 >

	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic

'ignorecase'オプションをoffにすることで、"The Start"パターンの検索を明示的に
大文字と小文字を分別させています。また、保存しておいた値を後で戻しています。
もう1つの方法としては、パターンに"\C"をつけることです。|/\C|を参照。


演算
----

上で述べたような基本的なアイテムを組み合せるとより興味深くなります。数値演算
を始めましょう。

	a + b		加算
	a - b		減算
	a * b		乗算
	a / b		除算
	a % b		剰余演算(余りを得る)

演算子の優先順位は普通の計算の場合と同じです。例を挙げましょう。 >

	:echo 10 + 5 * 2
<	20 ~

カッコを使って優先順位を上げることもできます。別に普通のことですね。 >

	:echo (10 + 5) * 2
<	30 ~

文字列は"."演算子を使って連結できます。 >

	:echo "foo" . "bar"
<	foobar ~

":echo"コマンドに複数の文字列を与えると、空白文字1つでそれらを接続します。例で
はパラメタは１つの式になっていますから、そのような空白文字は挿入されていませ
ん。

C言語からは条件演算子を借りました。 >

	a ? b : c

"a"の結果がTrueであれば、"b"となり、そうでなければ、"c"となります。 >

	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
<	i is small ~

３つの部分は事前に評価(evaluate)されますので、このように動くと考えることも
できます。

	(a) ? (b) : (c)

==============================================================================
*41.4*	条件文

":if"コマンドは条件が成立した場合に限り、以降のステートメントを":endif"が見
つかるまで実行します。記述形式はこのようになります。

	:if {condition}
	   {statements}
	:endif

{condition}で与えられた式を評価してTrue(０以外)であれば、{statements}の内容
を実行します。{condition}も{statements}も正しく記述したコマンドでなければな
りません。ここにゴミがあると、vimは":endif"をうまく見つけられなくなります。
条件文では":else"も使えます。その場合の記述形式はこのようになります。

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

２つ目の{statements}は最初の条件を満たさない場合にだけ実行されます。
最後に":elseif"があります。

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif

これは":else"＋"if"と全く同様に動きます。でもこれを使うと余分な":endif"を使
わなくて済みます。
vimrcファイルで便利に使えるサンプルを例にしましょう。これは'term'オプション
の内容によって、それぞれに依存する何かを行うためのスクリプトです。 >

	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif


論理演算子
----------

既に述べた例の中でも論理演算子を使っています。最もよく使うものを示します。

	a == b		等しい
	a != b		等しくない
	a >  b		より大きい
	a >= b		より大きいか等しい
	a <  b		より小さい
	a <= b		より小さいか等しい

この結果は条件に合致していれば１、そうでなければ０となります。例を示しま
しょう。 >

	:if v:version >= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif

"v:version"というのはvimが定義している変数で、これにはvimのバージョン値が入
ります。version6.0は600となります。version6.1なら601です。
これはvimの複数のバージョンで動作するスクリプトを書く時に重宝します。
|v:version|もどうぞ。

論理演算子は数値でも文字列でも使えます。２つの文字列を比較する時、数値差を使
います。この数値にはバイト値を比べますが、一部の言語では必ずしも正しい結果と
ならない場合があります。
文字列と数値を比較する時は、文字列をまず数値に変換します。ちょっとトリッキー
なんですが、文字列が数字列でない時は、その値が０とみなされます。例をあげま
しょう。 >

	:if 0 == "one"
	:  echo "yes"
	:endif

これは"yes"と表示されます。というのは"one"というのは数字列ではありませんから
その変換結果が０となるためです。

文字列にはさらに２つの論理演算子があります。

	a =~ b		パターンと合致する
	a !~ b		パターンと合致しない

左辺の"a"は文字列として扱い、右辺の"b"は何か検索したいパターンとして扱います。
次に例を示します。 >

	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str dows not end in a full stop"
	:endif

パターンにシングルクオートで囲った文字列を使っているのがポイントです。これな
らバックスラッシュをそのまま使えるので便利です。これをダブルクオートで囲むと
バックスラッシュを２重に書く必要があるのでバックスラッシュだらけになってしま
います。

'ignorecase'オプションは文字列の比較でも影響を与えます。影響を避けるには、
大文字小文字を区別する時は"#"、しない時は"?"を演算子につけます。つまり"==?"
とすれば、２つの文字列を大文字小文字を無視して同じ文字列かを返し、"!~#"なら
大文字小文字を区別した上でパターンに合致するかどうかをチェックします。論理演
算子の全リストは|expr-==|をご覧ください。


他のループコマンド
------------------

":while"コマンドについては既に述べましたが、":while"と":endwhile"の中で使え
るステートメントがまだ２つあります。

	:continue		ループの先頭に戻る。ループは脱けない。
	:break			":endwhile"まで進み、ループを脱ける。

例： >

	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile

":sleep"コマンドを使うと一定時間、何もしないようにできます。"50m"という指定
なら、50ミリ秒となります。また":sleep 4"であれば、４秒スリープします。

また、":for"コマンドを使うことでもループができます。|41.8|を参照。

==============================================================================
*41.5*	式を実行する

ここまではスクリプトのコマンドを直接実行するものばかりでした。":execute"コマ
ンドを使うと、式の評価結果をコマンドとして実行することができます。これは動的
にコマンドを生成して実行させることのできる極めて強力な手法です。
次の例は変数に格納した文字列をタグ名とみなしてタグジャンプするコマンドです。 >

	:execute "tag " . tag_name

"."は文字列"tag "と変数"tag_name"の＊内容＊を連結します。変数"tag_name"には
"get_cmd"という値が入っていたとすると、実際にはこのようなコマンドを実行する
ことになります。 >

	:tag get_cmd

":execute"コマンドはコマンド行のコマンド(コロンコマンド)のみ実行できます。
":normal"コマンドを使うと、通常コマンドを実行できます。ただし、このコマンド
のパラメタは式ではなく、コマンド文字の集合として扱います。例を示します。 >

	:normal gg=G

このコマンドは最初の行にジャンプして"="オペレータを使って全行のフォーマット
を整えます。
":normal"のパラメタとして式を指定したい場合は、":execute"コマンドを組み合せ
ます。例をあげます。 >

	:execute "normal " . normal_commands

"normal_commands"という変数には通常モード用のコマンドが入ってなければなりま
せん。
また、":normal"には完全なコマンドをパラメタとして与えます。そうでないと、vim
はパラメタ数の最後まで走ってから中断してしまいます。例えば、挿入モードを使う
のであればかならずその挿入モードを終了しなくてはなりません。この例はちゃんと
動きます。
>
	:execute "normal Inew text \<Esc>"

これは"new text "という文字列を現在行に追加します。末尾の"\<Esc>"をご覧くだ
さい。これはスクリプトの中での本当の<Esc>記号が入力されるのを避けるのに必要
です。

文字列を実行するのでなく、それを評価して値を取得したいときは、eval()を使いま
す: >

	:let optname = "path"
	:let optval = eval('&' . optname)

文字'&'を"path"の前につけているので、eval()の引数は"&path"となります。そのため、
この結果はオプション'path'の値となります。
同じことは次のようにしてもできます: >
	:exe 'let optval = &' . optname

==============================================================================
*41.6*	関数の利用

vimは多くの関数を定義しています。また膨大な数の機能をその方法で提供していま
す。この節ではいくつかの例を使って説明を行います。機能の全リストについては
|functions|をご覧ください。

関数の呼び出しは":call"コマンドで行います。パラメタは"("と")"の中に","で区切
って指定します。このようになります。 >

	:call search("Date: ", "W")

上の例では search() 関数を"Date:"と"W"をパラメタとして呼び出しています。
search()関数は最初のパラメタが検索パターンで、２つ目がフラグ指定となります。
"W"フラグはファイルの末尾に達した時に１行目に戻らない(ラップしない)という意
味です。

関数は式の中で使うこともできます。例を示します。 >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

getline() 関数は現在のバッファから１行を抽出する関数です。パラメタには行番号を
指定します。この場合は"."ですが、これは現在カーソルのある行を示します。
substitute()関数は":substitute"コマンドとほぼ同じです。最初のパラメタは置き換
えを実行する文字列で、２つ目のパラメタはパターン、３つ目は置き換える文字列、最
後のパラメタはフラグです。
setline() 関数は１つ目のパラメタでの指定行を、２つ目のパラメタの文字列に設定し
ます。この例ではカーソル位置の行をsubstitute()の結果と置き換えます。ですから、
この３つのステートメントの実行結果はこれと同じです。 >

	:substitute/\a/*/g

関数の利用はsubtitute()呼び出しの前後でより多く動かすようになると、がぜん面白
くなります。


関数							*function-list*

関数には多くの種類があります。ここで使われ方によって分類して説明します。アル
ファベット順のリストは|functions|にあります。関数名の上でCTRL-]を押せば詳細な
説明がご覧いただけます。

文字列繰作:
	nr2char()		ASCII値から文字を得る
	char2nr()		文字のASCII値を得る
	str2nr()		文字列を数値に変換する
	printf()		%項目に従って文字列を整形する
	escape()		'\'で始まるように文字をクオートする
	tr()			ある文字の集合を別の文字の集合へ置き換える
	strtrans()		文字列を印刷可能な状態とする
	tolower()		文字列を小文字にする
	toupper()		文字列を大文字にする
	match()			文字列の中でパターンが一致する桁位置を返す
	matchend()		文字列の中でパターンと一致する末尾の桁位置を
				返す
	matchstr()		文字列の中で一致したパターンを返す
	matchlist()		matchstr()と同様だが、部分一致も返す。
	stridx()		長い文字列の中にある短かい文字列の最初の位置
	strridx()		長い文字列の中にある短かい文字列の最後の位置
	strlen()		文字列の長さ
	substitute()		パターンに合致する文字列を他のものに入れ換
	submatch()		":substitute"の中で合致した部分を得る
	strpart()		文字列の一部分を得る
	expand()		特定のキーワードを拡張する
	iconv()			テキストのエンコーディングを変換する
	byteidx()		文字列におけるある文字のバイトのインデックス
	repeat()		文字列を複数回繰り返す
	eval()			文字列の式を評価する

リスト操作:
	get()			要素を取得。存在しないインデックスでもエラーを
				出さない
	len()			リスト中の要素の個数
	empty()			リストが空であるか判定する
	insert()		リストの任意の位置に要素を挿入する
	add()			リストに要素を追加する
	extend()		リストにリストを連結する
	remove()		リストから1個以上の要素を取り除く
	copy()			リストの浅いコピーを作成する
	deepcopy()		リストの完全なコピーを作成する
	filter()		リストから選択された要素を取り除く
	map()			リストの各要素を変換する
	sort()			リストをソートする
	reverse()		リストの並び順を反転させる
	split()			文字列を分割し、リストにする
	join()			リストの要素を連結し、文字列にする
	range()			数列リストを返す
	string()		リストの文字列表現
	call()			リストを引数として関数を呼ぶ
	index()			リスト中の要素のインデックス
	max()			リスト中の最大値
	min()			リスト中の最小値
	count()			ある要素がリスト中に出現する回数を返す
	repeat()		リストを複数回繰り返す

辞書操作:
	get()			辞書の要素を返す。存在しないキーでもエラーを出
				さない
	len()			辞書の要素の個数
	has_key()		あるキーが辞書に含まれているか判定する
	empty()			辞書が空であるか判定する
	remove()		辞書から要素を取り除く
	extend()		ある辞書の要素をすべて別の辞書に追加する
	filter()		辞書から選択された要素を取り除く
	map()			辞書の各要素を変換する
	keys()			辞書の全キーのリストを取得する
	values()		辞書の全値のリストを取得する
	items()			辞書の全キー・値のペアを取得する
	copy()			辞書の浅いコピーを作成する
	deepcopy()		辞書の完全なコピーを作成する
	string()		辞書の文字列表現
	max()			辞書中の最大値
	min()			辞書中の最小値
	count()			ある値が出現する回数を返す

変数:
	type()			変数の型
	islocked()		変数がロックされているか判定する
	function()		関数名からFuncrefを取得する
	getbufvar()		指定バッファの変数値を得る
	setbufvar()		指定バッファに変数を設定する
	getwinvar()		指定ウィンドウの変数値を得る
	gettabwinvar()		指定ウィンドウ・タブページから変数値を取得する
	setwinvar()		指定ウィンドウに変数を設定する
	settabwinvar()		指定ウィンドウ・タブページに変数を設定する
	garbagecollect()	メモリの解放を指示する

カーソルとマークの位置:
	col()			カーソル位置かマーク位置の桁位置を得る
	virtcol()		カーソル位置かマーク位置の画面上の桁位置を得る
	line()			カーソル位置かマーク位置の行番号を得る
	wincol()		カーソルのウィンドウカラム番号
	winline()		カーソル位置の画面上での行数
	cursor()		カーソルを指定した位置に移動させる
	getpos()		カーソル・マークなどの位置を取得する
	setpos()		カーソル・マークなどの位置を設定する
	byte2line()		指定のバイト位置の行番号を得る
	line2byte()		指定の行のバイト位置を得る
	diff_filler()		ある行より上に挿入された行の数を取得する

現在のバッファ内のテキストの繰作:
	getline()		バッファから行を得る
	setline()		バッファの行を入れ換える
	append()		バッファに行・行のリストを追加する
	indent()		指定の行をインデントする
	cindent()		Ｃ言語のルールに基いてインデントを行う
	lispindent()		Lisp 言語のルールに基いてインデントを行う
	nextnonblank()		次の空行を探す。
	prevnonblank()		逆方向に空行を探す
	search()		パターンに合致する場所を探す
	searchpos()		パターンに合致する場所を探す
	searchpair()		start/skip/endの呼応しているものを探す
	searchpairpos()		start/skip/endの呼応しているものを探す
	searchdecl()		ある名前の宣言を探す

システム関数とファイル繰作:
	glob()			ワイルドカードを拡張する
	globpath()		指定のディレクトリのワイルドカードを全部拡張
	findfile()		ディレクトリのリストからファイルを探す
	finddir()		ディレクトリのリストからディレクトリを探す
	resolve()		ショートカットがどこを示しているか探す
	fnamemodify()		ファイル名を変更する
	pathshorten()		パス中のディレクトリ名を短くする
	simplify()		パスの意味を変えずに簡略化する
	executable()		実行形式ファイルかどうかをチェックする
	filereadable()		ファイルが読み込み可能かどうかをチェックする
	filewritable()		ファイルが書き込み可能かどうかをチェックする
	getfperm()		ファイルのパーミッションを取得する
	getftype()		ファイルの種類を取得する
	isdirectory()		ディレクトリがあるかどうかをチェックする
	getfsize()		ファイルのサイズを取得する
	getcwd()		現在のカレントディレクトリを得る
	tempname()		テンポラリファイルの名前を得る
	mkdir()			create a new directory
	delete()		ファイルを削除する
	rename()		ファイル名を変える
	system()		シェルコマンドを実行し、その結果を知る
	hostname()		システムの名称を得る
	readfile()		ファイルを読み込み、行のリストにする
	writefile()		行のリストをファイルに書き込む

日付と時刻:
	getftime()		ファイルの最終更新日時を得る
	localtime()		現在時刻を秒単位で得る
	strftime()		時刻を文字列に変換する
	reltime()		現在時刻または経過時間を正確に取得する
	reltimestr()		reltime()の結果を文字列に変換する

バッファ、ウィンドウ、パラメタリストの繰作
	argc()			パラメタリストの項目数
	argidx()		パラメタリスト中の現在の位置
	argv()			パラメタリストから１つを得る
	bufexists()		バッファがあるかどうかをチェックする
	buflisted()		バッファがあって、リストに入っていることを
				チェックする
	bufloaded()		バッファがあって、ロードされていることを
				チェックする
	bufname()		指定バッファの名前を得る
	bufnr()			指定バッファのバッファ番号を得る
	tabpagebuflist()	タブページ中のバッファのリストを返す
	tabpagenr()		タブページの番号を取得する
	tabpagewinnr()		タブページを対象にwinnr()と同様
	winnr()			現在バッファのウィンドウ番号を得る
	bufwinnr()		現在バッファのウィンドウ番号を得る
	winbufnr()		指定ウィンドウのバッファ番号を得る
	getbufline()		指定のバッファから行のリストを得る

コマンドライン:
	getcmdline()		現在のコマンドラインを取得
	getcmdpos()		コマンドラインにおけるカーソル位置を取得
	setcmdpos()		コマンドラインにおけるカーソル位置を設定
	getcmdtype()		現在のコマンドラインのタイプを返す

Quickfixとロケーションリスト:
	getqflist()		quickfixエラーのリスト
	setqflist()		quickfixを変更する
	getloclist()		ロケーションリストの項目のリスト
	setloclist()		ロケーションリストを変更する

インサートモード補完:
	complete()		マッチリストを設定する
	complete_add()		マッチリストに追加する
	complete_check()	補完を強制終了すべきかどうか判定する
	pumvisible()		ポップアップメニューが表示されているか判定

フォールド(折り畳み処理)
	foldclosed()		指定の行に閉じたフォールドがあるかチェック
	foldclosedend()		foldclosed()に似ている。最後の行番号を返す
	foldlevel()		指定の行のフォールドレベルをチェック
	foldtext()		閉じたフォールドの表示行を生成
	foldtextresult()	閉じた折りたたみに表示されているテキストを取得

シンタックスハイライト
	hlexists()		ハイライトグループがあるかチェック
	hlID()			ハイライトグループのIDを得る
	synID()			指定の場所のシンタックスIDを得る
	synIDattr()		シンタックスIDの指定の属性を得る
	synIDtrans()		変換したシンタックスIDを得る
	diff_hlID()		diffモードの指定位置のシンタックスIDを得る
	matcharg()		|:match|の引数の情報を得る

スペリング:
	spellbadword()		カーソル位置以降のスペルミスを探す
	spellsuggest()		スペル訂正の候補を返す
	soundfold()		単語のsound-a-like equivalentを返す

履歴
	histadd()		履歴に項目を追加
	histdel()		履歴から項目を削除
	histget()		履歴の項目を得る
	histnr()		履歴の最大番号を得る

会話処理
	browse()		ファイル選択ダイアログを開く
	browsedir()		ディレクトリ選択ダイアログを開く
	confirm()		利用者に選択をさせる
	getchar()		利用者の入力した文字を得る
	getcharmod()		最後に入力した識別子(modifier)を得る
	input()			利用者の入力した行を得る
	inputlist()		利用者にリストから項目を選択させる
	inputsecret()		利用者の入力した行を得る。ただし表示はしない
	inputdialog()		ダイアログを使って利用者の入力した行を得る
	inputsave()		先行した入力を保存して状態をクリアする
	inputrestore()		inputsave()で保存した状態に戻す

GUI:
	getfontname()		現在使っているフォントの名前を取得
	getwinposx()		GUIのVimウィンドウのX座標
	getwinposy()		GUIのVimウィンドウのY座標

vimサーバ
	serverlist()		サーバ名のリストを返す
	remote_send()		vimサーバにコマンド文字を送る
	remote_expr()		vimサーバで式を評価する
	server2client()		vimサーバのクライアントに返信を送付する
	remote_peek()		vimサーバから返信があったかどうかをチェック
	remote_read()		vimサーバからの返信を読み込む
	foreground()		vimのウィンドウを前面に持ってくる
	remote_foreground()	vimサーバのウィンドウを前面に持ってくる

ウィンドウサイズと位置:
	winheight()		指定ウィンドウの高さを取得
	winwidth()		指定ウィンドウの幅を取得
	winrestcmd()		ウィンドウサイズを復元するコマンドを返す
	winsaveview()		カレントウィンドウのビューを取得
	winrestview()		カレントウィンドウの保存したビューを復元

その他
	mode()			現在の編集モードを得る
	visualmode()		最後にビジュアルモードを使った時の情報
	hasmapto()		マップがあるかどうかをチェック
	mapcheck()		合致するマップがあるかどうかをチェック
	maparg()		マップのrhsを得る
	exists()		変数、関数などがあるかどうかチェック
	has()			vimが機能をサポートしているかをチェック
	changenr()		最近の変更の番号を返す
	cscope_connection()	cscope接続があるかどうかをチェック
	did_filetype()		FileType自動コマンドを使っているかをチェック
	eventhandler()		イベントハンドラによって起動されたかをチェック
	libcall()		外部ライブラリの関数を呼ぶ
	libcallnr()		同上、ただし、復帰値を見る

	getreg()		レジスタの値を得る
	getregtype()		レジスタのタイプを得る
	setreg()		レジスタの値を設定する

	taglist()		マッチするタグのリストを取得
	tagfiles()		タグファイルのリストを取得

==============================================================================
*41.7*	関数の定義

vimでは自作の関数を定義することができます。基本的な関数定義は次のような構造
となります。 >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	Note:
	関数名は１文字目が必ず大文字にしなければなりません。

ここで２つの数値のうち小さい方を返す関数を作ってみましょう。関数は次のような
行で始まります。 >

	:function Min(num1, num2)

ここで、関数名が"Min"であること。パラメタは２つで、それぞれ"num1"、"num2"と
いう名前であることがわかります。
最初に行うのはどちらが小さいかをチェックすることです。
   >
	:  if a:num1 < a:num2

"a:"は特殊なプレフィクスで、この変数が関数のパラメタであることを示します。
さて、ここで小さい方の値を変数"smaller"に代入しましょう。 >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

変数"smaller"はローカル変数です。関数内で使っている変数は、その関数内でロー
カルです。但し"g:"や"a:"や":s"といったプレフィクスを関数の前につけた場合は例
外です。

	Note:
	関数内からグローバル変数にアクセスするには、"g:"を変数名の前に付け
	る必要があります。つまり、関数内では"g:count"はグローバル変数"count"
	のことです。しかし"count"というのは関数内にローカルな別の変数です。

ここで呼び出し元に最少値を返すために":return"ステートメントを使います。そし
て、関数を終了します。 >

	:  return smaller
	:endfunction

この関数を通して記述すると次のようになります。 >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

短い関数が好きな人向けには、次のコードも同じことをします: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction

ユーザ定義関数は組み込み関数の場合と全く同じ方法で呼び出します。違いは名前だ
けです。上で定義した"Min"関数の場合なら次のように使います。 >

	:echo Min(5, 8)

今だけは（？？）、vimは関数の各行を解釈し、関数が実行されます。
未定義の変数や関数を使うといった間違いがあれば、エラーメッセージを表示しま
す。関数を定義している時はエラーは検出されません。

関数が、パラメタなしの":endfunction"や":return"に辿り着くと、復帰値は０にな
ります。

既存の関数を定義し直すには":function"コマンドに"!"を付けます。 >

	:function!  Min(num1, num2, num3)



範囲の利用
----------

":call"コマンドには行範囲を渡すことができます。これには2つの方法のうちどちらか
を適用します。1つは、関数を定義する時に"range"キーワードを使う方法です。これを
使うとコマンド自身に行範囲が指定できるようになります。
関数は"a:firstline"と"a:lastline"という2つの変数を暗黙的に受け取ります。この２
つの変数は関数が呼ばれた時の範囲の開始行番号、最終行番号になります。例を挙げま
しょう。 >

	:function Count_words() range
	:  let n = a:firstline
	:  let count = 0
	:  while n <= a:lastline
	:    let count = count + Wordcount(getline(n))
	:    let n = n + 1
	:  endwhile
	:  echo "found " . count . " words"
	:endfunction

この関数はこのように呼び出すことができます。 >

	:10,30call Count_words()

これを実行させると、関数を１度だけ実行し、単語数の合計を表示します。

もうひとつ、"range"キーワードを使わない関数で行範囲を使う方法があります。
この場合、範囲の各行に対して１度づつ関数が呼び出されます。例を示しましょう。
>
	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction

この関数を次のように呼び出したとします。 >

	:10,15call Number()

この場合ですと、関数は６回呼び出されます。


可変個のパラメタ
----------------

vimではパラメタが可変個となるような関数を定義できます。例えば、次のコマンド
では少なくとも１つのパラメタ(start)と最大20個の追加パラメタを受けとります。 >

	:function Show(start, ...)

変数"a:1"には１つ目のオプションパラメタ、"a:2"は２つ目、"a:3"は３つ目、とな
ります。変数"a:0"にはオプションパラメタの数が入ります。
このようになります。 >

	:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echon "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

ここでは、後述の":echo"コマンドでハイライト表示をさせるために、":echohl"を使
っています。":echohl None"はそれを停止しています。":echon"コマンドは":echo"
と同様ですが、最後の改行を出力しません。

変数a:000を使うこともできます。これは"..."で表した引数全部のリストです。
|a:000|を参照。


関数のリスト
------------

":function"コマンドは全てのユーザ定義関数のリストを出力します。 >

	:function
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

関数が何を実行するかを見るには、":function"のパラメタに関数名を指定します。 >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


デバッグ
--------

デバッグ中やエラーメッセージの表示時に行番号が表示されると助かります。
デバッグモードについては|debug-scripts|をご覧ください。
また、'verbose'オプションを12以上に設定すると全ての関数呼び出しを見ることが
できます。15以上にすると、実行する各行の内容も見ることができます。


関数の削除
----------

例えばShow() 関数を削除するのはこのようにします。 >

	:delfunction Show

存在しない関数を削除しようとするとエラーとなります。


関数への参照

ときに、関数を参照する変数があると役に立つことがあります。これは関数function
()をつかうことで実現できます。この関数は関数の名前を受け取り、その関数への参照
を返します: >

	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
<	Wrong! ~

Note 関数への参照を保持する変数の名前は大文字で始めなければなりません。そうで
ないと組み込み関数の名前との混乱を招きます。
変数が参照する関数を呼び出すには、関数call()を使います。そのとき最初の引数は関
数への参照で、2番目の引数は全引数のリストになります。

関数への参照は、次節で説明される辞書と組み合わせたときもっとも役に立ちます。

==============================================================================
*41.8*	リストと辞書

ここまでは基本型(文字列と数値)を扱ってきました。Vimはリストと辞書という複合型
も備えています。

リストとは、要素の順序つきの列です。要素はどんな種類の値でもよく、数値のリスト、
リストのリスト、さらには要素の混在したリストでも作れます。3個の文字列からなる
リストを作るには次のようにします: >

	:let alist = ['aap', 'mies', 'noot']

リストの要素は角括弧で囲み、コンマで区切られます。空のリストを作るには次のよう
にします: >

	:let alist = []

関数add()を使うとリストに要素を追加することができます: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

リストの連結には + を使います: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

直接リストを拡張するには次のようにします: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

add()とは効果が異なることに注意してください: >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

add()の第二引数は1つの要素として追加されます。

FORループ

リストを使ってできる素晴らしいことの1つが、リストに対する繰り返しです: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

上の例は、リスト"alist"の各要素に対して、その値を変数"n"に代入しながらループを
行います。forループの一般的な書式は次の通りです: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

ある回数だけループするには、その長さのリストを使います。関数range()を使うと、
そのようなリストを作成できます: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

range()が生成するリストの最初の要素は0であることに注意してください。そのた
め、最後の要素はリストの長さより1小さい値になります。
最大値、ステップ幅を指定することもでき、逆方向に進むこともできます: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

より有用な例として、バッファ中の行に対するループ: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

1から20行目(両端を含む)を調べ、そこに含まれる日付を全て表示しています。


辞書

辞書はキーと値のペアを保持します。キーがわかっていれば、値は高速に検索すること
ができます。辞書は波括弧で作ります: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

そして角括弧の中にキーを書くことで単語を検索します: >

	:echo uk2nl['two']
<	twee ~

辞書の定義の一般的な書式は次の通りです: >

	{<key> : <value>, ...}

空の辞書とは、どんなキーも持たない辞書のことです: >

	{}

辞書の可能性は巨大です。辞書を扱う関数もたくさんあります。例えば、キーのリスト
を取得してそれに対してループするには次のようにします: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

キーはソートされていないことに注意してください。特定の順序にするには、リストを
ソートします: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

しかし要素を定義された順序に戻すことは決してできません。そのような目的にはリス
トを使ってください。リストは順序を保って要素を保持します。


辞書の関数

辞書の要素は角括弧でインデックスを指定して取得します: >

	:echo uk2nl['one']
<	een ~

メソッドはより少ない記号でこれと同じことをします: >

	:echo uk2nl.one
<	een ~

これはキーがアルファベット、数字、アンダースコアから構成される場合だけうまくい
きます。次のようにしても新しい値を代入することができます: >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

そして、特別なことができます: 関数を定義して、それへの参照を直接辞書に入れるこ
とができます: >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

これを実行してみましょう: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

最初に気付くのは、":function"の行の最後の"dict"でしょう。これは、その関数が辞
書から使われることを示します。ローカル変数"self"がその辞書を指すようになりま
す。
次に、複雑なreturnコマンドを分解してみましょう: >

	split(a:line)

関数split()は文字列を受け取り、空白文字で単語に区切ってリストにして返します。
そのため、この例での戻り値は次のようになります: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

このリストがmap()関数の第一引数になります。map()はリストの各要素の値を"v:val"
に設定しながら第二引数を評価します。これによりforループより短いコードにできま
す。このコード: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

は次のコードと同値です: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

関数get()はそのキーが辞書に入っているかをチェックします。入っていればその値を
引き出します。入っていなければデフォルト値(この例では'???')を返します。キーが
入っていないときにエラーになってほしくないという場合に便利です。

関数join()はsplit()の逆を行います。つまり単語のリストをスペースで区切って連結
します。
split(), map(), join() の組み合わせは、単語からなる行をとても簡潔に処理するす
ばらしい方法です。


オブジェクト指向プログラミング

変数も関数も辞書に入れることができます。辞書をオブジェクトのように使うことが実
際できるのです。
上ではオランダ語から英語に翻訳するために辞書を使いました。これをほかの言語に対
しても行いたいと思うかもしれません。まずオブジェクト(辞書でもある)を作りま
しょう。しかし翻訳する単語ではなく、翻訳する関数を入れます: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

単語を翻訳するのに'self.words'を使う前の関数とはだいぶ違います。今度のは
self.wordsがありません。よって、これは抽象クラスと呼ぶことができます。

オランダ語を翻訳するオブジェクトをインスタンス化しましょう: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

そしてドイツ語の翻訳器は次のようになります: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei ein ~

"transdict"辞書のコピーを作るのにcopy()関数が使われていて、そのコピーに単語を
追加して変更していることに気づくでしょう。もちろん元の方はそのまま残ります。

さらに一歩進んで、あなた自身の翻訳器を作ることができます: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

ここで"trans"は2つのオブジェクト(辞書)のどちらか1つを参照します。コピーは作ら
れていません。リストと辞書の同一性についてのより詳しい情報は|list-identity|と
|dict-identity|にあります。

ここで対応していない言語も使いたいと思うかもしれません。関数translate()を何も
しないように上書きすることができます: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

!を使って既に存在している関数への参照を上書きしていることに注意してください。
認識できない言語が見つかったときは"uk2uk"を使うことにしましょう: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

さらなる情報については|List|と|Dictionaries|を参照してください。

==============================================================================
*41.9*	例外

例題から始めましょう: >


	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

":read"コマンドはファイルがなければ失敗します。このコードはエラーメッセージ
は生成せずに、ユーザーに代りのメッセージを表示します。

":try"と":endtry"コマンドの間のエラーは例外になります。例外は文字列です。エ
ラーのときには文字列がエラーメッセージを含んでいます。また、全てのエラーメッ
セージは番号を持っています。この例題のエラーは"E484:"を含んでいます。この番
号は変わらないことが保証されています(テキストは翻訳されるなどして変わるかも
しれません)。

":read"コマンドが他のエラーを起こした場合、"E484:"というパターンはマッチしな
いでしょう。したがってその例外はキャッチされずに通常のエラーメッセージを表示
します。

あなたはこのようにしたくなるかもしれません: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

これは全ての例外をキャッチするという意味です。しかしこれでは"E21: Cannot
make changes, 'modifiable' is off"のような有効なエラーに気づくことができませ
ん。

ほかにも便利な仕組みに":finally"コマンドがあります: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry

これはカーソル行からファイルの最後までフィルタを通します。"filter"コマンドは
ファイルの名前を引数に取ります。こうすれば、":try"と":finally"の間で問題が起
こったときや、ユーザーがCTRL-Cを押して操作をキャンセルしたときにも"call
delete(tmp)"は必ず呼ばれます。一時ファイルを残す心配はありません。

例外についてさらに詳しい情報はリファレンスマニュアルの|exception-handling|を
参照してください。

==============================================================================
*41.10*	いろいろな留意事項

ここではvimスクリプトに適用される項目の概要を述べます。他の場所でも同じよう
な説明を行っていますが、手頃なチェックリストに使えることでしょう。


行末記号はシステムによって異なります。Unixでは<NL>文字を使いますが、MS-DOS
やWindows、OS/2などでは<CR><LF>を使います。末尾が<CR>となっているようなマッ
プを使う時には気を付けてください。|:source_crnl|もご覧ください。


空白類
------

空行は利用可能です。単に無視します。

行頭の空白類(空白文字とTAB)は常に無視します。パラメタ間の空白類(例えば、後述
の"set"と"coptions"の間)は１つの空白文字に圧縮して、セパレータとなります。
また、最後の文字より後にある空白類は場合によって、無視されたりされなかったり
します。次のようになるわけです。

次のような"="記号を含むような":set"コマンドがあるとします。 >

	:set cpoptions    =aABceFst

"="の直前にある空白類は無視されます。でも"="の後には空白がありません！

オプション値に空白類を含ませるには、次のようにバックスラッシュ("\")でエス
ケープする必要があります。 >

	:set tags=my\ nice\ file

同じ目的で次のように書くと、 >

	:set tags=my nice file

これはエラーとなります。というのは上の行はこのように展開されるためです。 >

	:set tags=my
	:set nice
	:set file


コメント
--------

コメントは " (ダブルクオート)記号で始めます。この文字の後に書いてあるものは
行末に至るまで全てをコメントとみなし、無視します。但しコメントと考えないよう
なコマンドは例外です。例を下にあげておきます。
コメントは行のどこからでも始めることができます。

コメントでちょっとした「キャッチ」を作ろうとして次のようにしたとします。 >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

短縮形'dev'は'development	" shorthand'に拡張されます。<F3>は実際には
'o# ....'以降、'" insert include'までの行全体となります。また"execute"コマン
ドはエラーとなり、"!"コマンドはそれ以降を全部シェルに渡すため、" 記号が１つ
しかない、というエラーになるでしょう。
結局、":map"、":abbreviate"、":execute"、"!"コマンドでは(このような制限があ
るコマンドは他にもあります)コメントは使えないということです。
":map"、":abbreviate"、":execute"に関しては、こういうズルイ方法を使うと、コ
メントを付けられます。 >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

'|'文字を使うと、コマンドを複数に分割できます。この場合、２つ目のコマンドに
はコメントしかないということになります。最後のlsの場合は、|:execute|と'|'の2つ
を使わないとできません: >
	:exe '!ls *.c'			|" list C files

":map"と":abbreviate"の場合は'|'の前に空白類を置かないように注意してくださ
い。このコマンドでは行末か'|'の前までの全文字が含まれてしまいます。この振舞
いのため、次のように行末に空白があっても見えないわけです。 >

	:map <F4> o#include

この問題に気づきやすくするには、vimrcを編集する時には'list'オプションをonにす
るのがよいでしょう。

Unixの場合は、行をコメントにする特別な方法があります。それはVimスクリプトを実
行可能にすることです: >
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

"#"コマンドはその行を行番号をつけて表示します。'!'をつけることで、このコマンド
は何もしなくなります。よってそのファイルを実行するコマンドを記述することができ
ます。|:#!| |-S|


落とし穴
--------

次の例には大きな問題があります。

	:map ,ab o#include
	:unmap ,ab

ここのunmapコマンドはうまく動きません。というのは",ab "(末尾に空白あり)を
unmapしようとするためです。 これはマップシーケンスに存在しません。エラーが発
生しますが、理由を見つけるのが非常に難しいです。これは行末の空白類が見えない
からです。

":unmap"コマンドの後にコメントを追加した場合にも同じことが発生します。 >

	:unmap ,ab     " comment

確かにこのコマンドではコメント部は無視してくれます。でもvimは",ab     "(空白
５個付き)のマップを削除しようとしますが、そんなのはありません。これはこのよ
うに書き直せば大丈夫です。 >

	:unmap ,ab|    " comment


ビューの復元
------------

何らかの変更を加えてから、カーソルのあった場所に戻りたい時があります。
場所自体はマークで復元できますが、画面に表示される行範囲は一致しません。
単にマークした場所を復元するのもいいのですが、そうすると同じ行がウィンドウの最上段
に表示されます。
この例は現在行をヤンクして１行目の上にプットし、ビューを復元します。 >

	map ,p ma"aYHmbgg"aP`bzt`a

これが何をするか見ていきましょう。 >
	ma"aYHmbgg"aP`bzt`a
<	ma			現在のカーソル位置をマーク a をつける
	  "aY			現在行をレジスタ a にヤンク
	     Hmb		画面の最上段にジャンプし、マーク b をつける
		gg		ファイルの１行目にジャンプ
		  "aP		レジスタ a の内容を１行目の上にプット
		     `b		マーク b にジャンプ
		       zt	カーソル行を画面の１行目になるようにスクロール
			 `a	最初にマークした場所にジャンプ


PACKAGING
パッケージ

あなたが作った関数の名前が他の人から入手したものとダブるのを避けるには、次の
ように行ってください。
- 各関数名の前にユニークな文字列を付けます。私はよく短縮形を使っています。
  例えば、"OW_"をオプションウィンドウ関数に使うといった具合です。
- 自作の関数の定義を１つのファイルに入れます。その上で、関数がロードされたか
  どうかをチェックするためのグローバル変数を設定します。そのファイルを再度
  読み込もうとした時は、まずその関数をアンロードするようにします。
例: >

	" これは XXX のパッケージです

	" 再ロードであれば、関数を削除します
	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	" ロードが完了した印として、グローバル変数に反映します
	let XXX_loaded = 1

==============================================================================
*41.11*	プラグインを書く 				*write-plugin*

多くの人が使えるようなvimスクリプトを書くこともできます。これをプラグインと呼
びます。vimのユーザはあなたが作ったプラグインを"plugin"ディレクトリにドロップ
するだけで、その機能をきちんと使えます。|add-plugin|も併せてご覧ください。

実際にはプラグインには２種類あります。

  グローバルプラグイン    : 全タイプのファイル用
  ファイルタイププラグイン: 特定タイプのファイル用

この節では１つ目のグローバルプラグインについて説明します。ほとんどの項目は、
ファイルタイププラグインを書く時も利用できます。ファイルタイププラグイン独自
の点については次節の|write-filetype-plugin|をご覧ください。


名称
----

何よりも最初にしなければならないのはプラグインの名称を決めることです。プラグ
インが提供する機能は名前から明らかになるべきです。また誰か他の人が書いたプラ
グインで名前は同じだけど、内容が違っているようなものは避けるべきです。
名称は８文字以下にしてください。これは古いMS-Windowsシステムの抱える問題を避
けるためです。

入力ミスを集めた"typecorr.vim"というスクリプトがあります。ここではそれを例題
として利用します。

プラグインを誰でも使えるようにするには、いくつかのガイドラインに従ってくださ
い。ここでは１歩づつ説明します。このプラグインの完全なソースはこの節の末尾に
入っています。


ボディ
------

では、プラグインの本体部分に入りましょう。行番行は実際の番号です。 >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

もちろん、本当のリストはもっともっと長いです。

行番号は説明のために追加したものです。本当にプラグインを作る時には入力しない
でください。


へッダ
------

おそらく、新しいセットをプラグインに追加し、いくつかのバージョンができてしまう
でしょう。このファイルを配布すると、それを使った人々は、誰がこの素晴らしいプラ
グインを書いたのかを知りたいと思うでしょうし、意見をメールで送りたい場合にどこ
に送ればよいのでしょうか？
そのため、次のようなヘッダをプラグインに書いておいてください。 >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>

著作権とライセンスについて。プラグインがとても便利で配布を制限するだけの価値が
あるのなら、どうか、ライセンスにパブリックドメインかVimライセンス|license|のど
ちらかを使うことを検討してみてください。次の短い宣言をプラグインの最初のほうに
書いておくだけで十分です。 >

  4	" License:	This file is placed in the public domain.


行連結、副作用の回避					*use-cpo-save*

上の例の18行目では、行連結(|line-continuation|)を使っています。
'compatible'オプションをonにしているユーザはこれが問題となるでしょう。ですが
様々な副作用があるため、システム側で勝手に'compatible'をoffにするわけにはい
きません。これを避けるには'cpoptions'オプションをvimのデフォルト値に設定し、
後でそれを元に戻すようにします。これで行連結が使えますから、そのスクリプトは
たいていの環境で動くようになります。この設定は次のように行います。 >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo

最初に'cpoptions'の内容を変数"s:save_cpo"に保存します。プラグインの最後で、
その値を元に戻すわけです。

スクリプトにローカルな変数は|s:var|となる点に注意してください。グローバル変
数だと他のどこかで既に使っている可能性があります。スクリプト内だけで使うよう
な場合は常にスクリプトローカルな変数を使うようにしてください。


ロードの禁止
------------

あるプラグインをいつもではないけれど、時々ロードして利用したいと思うことがあ
ります。また、システム管理者が全員用のプラグインディレクトリにそのスクリプト
を入れたけれど、一般ユーザには自分で使いたいプラグインを使わせてあげたいこと
もあるでしょう。こういった場合、ユーザ側で特定のプラグインのロードを禁止でき
るように準備してあげないといけません。これは次のようにすれば実現できます。
>
  6	if exists("loaded_typecorr")
  7	  finish
  8	endif
  9	let loaded_typecorr = 1

これを使うとスクリプトの２重ロードを避けることもできます。２重ロードしてしま
うと、関数の２重定義エラーや自動コマンドを２回追加することによるトラブルを防
ぐことになります。
訳注: 要はユーザのvimrcなどで上記の"loaded_typecorr"というグローバル変数を定
訳注: 義してしまえばよいわけです。


マップ
------

さて、プラグインをもっと魅力あるものに仕上げましょう。カーソル下の単語をコレ
クションに追加するようなマップを追加します。このマップ用の一連のキー入力を拾
いますが、ユーザは既にそれを何か他の機能に使っているかもしれません。 プラグ
インを使う時にどのキーに割りあてるかをユーザ側に決めてもらうには、<Leader>
項目を使います。 >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd

"<Plug>TypecorrAdd"でも動くでしょうが、さらにできることがあります
訳注: The "<Plug>TypecorrAdd" thing will do the work,
訳注: more about that further on.

ユーザは"mapleader"変数にマップさせたい最初のキーシーケンスを設定できます。
ですから、ユーザが次のように実行したとします。 >

	let mapleader = "_"

この機能は最終的に"_a"に定義されます。ユーザがこれをやらなければ、デフォルト
値（バックスラッシュ）を使います。この場合は"\a"がマップとして定義されます。

<unique>の指定があることに注意してください。これは指定のコマンドがマップ済で
ある場合に、エラーを表示します。|:map-<unique>|もご覧ください。

ではユーザが独自のシーケンスを定義したい場合はどうしましょうか？これは次のよ
うな仕組みで実現できます。 >

 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif

ここでは"<Plug>TypecorrAdd"に対するマップが既にあるかどうかを調べ、"<Leader>a"
が未定義の場合に限りそれにマップされまう。ユーザはこれを自分のvimrcファイル
に置く機会が与えられます。 >

	map ,c  <Plug>TypecorrAdd

こうすれば、キーシーケンスを"_a"や"\a"でなく",c"に（自由に)割り合てられます。


パーツ
------

スクリプトが長大になってきた場合、これを複数に分割したくなります。これは関数
やマップを使うことで可能です。ただし、そのような内部用の関数やマップは他のス
クリプトから呼ばれるのは好ましくありません。例えば、Add()という関数を定義で
きます。でも他のスクリプトでも同じ名前の関数を定義しようとする可能性がありま
す。これを避けるには関数に"s:"というプレフィクスを付けてスクリプト内にローカ
ルな関数を定義できます。

新たに入力コレクションを追加する関数を定義します。 >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction

ここで、このスクリプトから s:Add() 関数を呼ぶことができます。他のスクリプト
も s:Add() 関数を定義できますが、いずれもそのスクリプトにローカルであり、同
じスクリプトの中からのみ呼び出すことができる。これ以外にグローバルなAdd()関
数を定義することもできます。これはまた上のいずれとも異なった関数です。

マップ定義では<SID>も使えます。これは現在のスクリプトを識別するためのスクリ
プトIDを生成します。"入力コレクション"プラグインでは次のように利用していま
す。 >

 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

ですから、ユーザが"\a"と入力すると次の手順でコマンドが起動します。 >

	\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()

もし、他のスクリプトが<SID>Add をマップしていても、スクリプトIDが違ったもの
になりますから、これは違ったマップとして定義できるのです。

ここでは s:Add() と書く代わりに <SID>Add() と書いている点に注意してください。
これはマップはスクリプトの外側でユーザ自身が入力するものであるためです。
<SID>はスクリプトIDに変換されますので、vimはどのスクリプトのAdd()関数をどの
スクリプトから探せばよいかわかるからです。

これはちょっと複雑です。ここではプラグインが別のプラグインと共同で処理を行う
ことを求められるためです。基本的なルールは２つです。１つはマップの<SID>Add()
を使うこと。もう１つは他の場所(スクリプトの中や自動コマンドやユーザ定義コマン
ド)にある s:Add() を使うことです。

メニュー項目を追加する方法でもマップと同じことができます。 >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

メニューにプラグインを追加するには"Plugin"ディレクトリを用いることをお勧めし
ます。この場合、選択できるのは１つの項目だけです。２つ以上を追加するにはサブ
メニューを作ることをお勧めします。例えば、"Plugin.CVS"というプラグインがあり
このプラグインはCVSの繰作をする"Plugin.CVS.checkin"と"Plugin.CVS.checkout"を
提供しているといった場合です。

28行目で":noremap"を使って他のマップが問題を引き起さないようにしているのに
注意してください。例えば、誰かが":call"を再マップしてしまうかも知れません。
24行目でも":noremap"を使っています。しかしこの場合は <SID>Addを再マップした
いのです。ここで"<script>"を使っているのはこのためです。これを指定するとスク
リプトにローカルな定義だけがマップの対象となるのです(|:map-<script>|)。26行
目でも":noremenu"で同じことをやっています。(|:menu-<script>|)


<SID>と<Plug>					*using-<Plug>*
-------------

<SID>と<Plug>はどちらも、入力したキーのマップが他のマップで使うためだけの
マップを防害するのを避けるのに使います。<SID>と<Plus>の違いに注意してくださ
い。

<Plug>	これはスクリプトの見える側です。これはユーザが一連のキー繰作を割り当
	てたいマップで使います。<plug>は実際に入力されることのない特殊なコー
	ドです。
	他のプラグインが同じ文字シーケンスを使うのと非常に違っていて、次のよ
	うな構造となります。 >
		<Plug> スクリプト名 マップ名
<	今までの例で言えば、スクリプト名は"Typecorr"であり、マップ名 は"Add"
	です。ですから具体的にはこのようになります。 >
		<Plug>TypecorrAdd
<	スクリプト名とマップ名の１文字目だけを大文字にします。こうすれば、ど
	こからがマップ名なのかがわかりやすくなります。

<SID>	これはスクリプトIDです。スクリプトIDは個々のスクリプトに与えられるユ
	ニークな識別子です。
	vimの内部では<SID>は"<SNR>123_"(123の部分はそれぞれ違う番号)に変換し
	ます。ですから関数"<SID>Add()"はあるスクリプトでは"<SNR>11_ADD()"と
	なり、また別のスクリプトでは"<SNR>22_And()"となります。
	これは実際に":function"コマンドを使って関数リストを表示すれば解りま
	す。マップでの<SID>の変換も全く同じです。これはマップからスクリプト
	ローカルな関数を呼び出す方法です。


ユーザ定義コマンド
------------------

今度はユーザ定義コマンドをコレクションに追加しましょう。 >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

ユーザ定義コマンドは同じ名前のコマンドがない場合のみ定義できます。そうでない
場合はエラーとなります。既存のユーザ定義コマンドを上書きするのに":command!"
を使うのは良くありません。ユーザは自分で定義したコマンドがどうして動かなく
なったのかわからなくなるであろうからです。|:command|をご覧ください。


スクリプト変数
--------------

先頭に"s:"が付いた変数はスクリプト変数です。これはスクリプトの中でだけ有効な
ものです。スクリプト外では変数として扱われませんこれは同じ変数名を複数のスク
リプトで使う時のトラブルを避けるための仕組です。変数はvimが稼動中はずっと存
在しています。同じスクリプトを再読み込みしても同じ変数が使われます。
|s:var|をご覧ください。

面白いのは変数はスクリプト内で定義されている関数や自動コマンド、ユーザ定義コ
マンドからでも使える点です。typecorrの例でも集めた単語の数をカウントできるよ
うに数行を追加してみましょう。 >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction

最初に s:count をスクリプトの中で４に初期化します。その後、s:Add()関数を呼び
出すと、s:count の値を１増やします。どこから関数が呼ばれても関係ありません。
それはこの関数が同じスクリプトの中で定義されているから、スクリプト内でローカ
ルな変数が使えるからです。


最後に
------

今まで説明してきた例題の最終形はこのようになります。 >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("loaded_typecorr")
  7	  finish
  8	endif
  9	let loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo

そうそう、33行目はまだ説明していませんでした。これはカーソル下の単語を新たな
コレクションとして適用します。マップと短縮形はここで拡張されることに気を付け
てください。たとえ":noremap"で定義したマップから呼び出された関数でも、です。

'fileformat'オプションに"unix"を設定する事を推奨します。そうすればVimスクリプ
トはどこでも動くでしょう。スクリプトの'fileformat'が"dos"に設定されていると
Unixでは動きません。|:source_crnl|も見て下さい。ファイルを書き込む前に次のよう
にすれば正しく設定されます。

	:set fileformat=unix


ドキュメント						*write-local-help*
------------

プラグイン用の何らかのドキュメントを作っておくのはとても良いことです。ユーザ
側でその動きを変更できるような場合は特に、です。|add-local-help|ではそれをど
のようにインストールされるかを説明しています。

"typecorr.txt"という名前のプラグイン用ヘルプファイルのサンプルを示します。 >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

最初の行だけはフォーマットに気を付けてください。この行の記述を元に"help.txt"
の"LOCAL ADDSIONS:"の節に概要を埋め込みます|local-additions|。１行目の１桁目に
は必ず"*"がなくてはなりません。ヘルプを追加したら":help"を実行して正しく追加で
きたことを確認してください。

ヘルプファイルに**で囲んでタグを追加することができます。ただし既存のヘルプのタ
グと同じものを使わないように気を付けてください。タグには自分のプラグイン名を使
えばよいでしょう。例えばこの例題であれば、"typecorr-setting"といった具合です。

ヘルプの他の部分を参照する時には || で囲みます。こうすれば簡単にリンク先のヘル
プを見ることができます。


ファイルタイプの定義					*plugin-filetype*
--------------------

ファイルタイプの定義がVimによって提供されていない場合、簡単に定義ファイルを作
ることができます。通常はファイル名がパターンにマッチしたときにファイルタイプを
セットするオートコマンドです。
例: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

この一行を'runtimepath'の最初にあるディレクトリ内の"ftdetect/foofoo.vim"に保
存してください。Unixなら"~/.vim/ftdetect/foofoo.vim"でしょう。ファイルタイプ
の名前をスクリプトファイルの名前にする決まりになっています。

もし望むならより複雑な検査をすることができます。例えばそのファイルに書かれた
言語を識別するためにファイルの中身を検査するなどです。|new-filetype|を参照し
てください。


サマリー						*plugin-special*

プラグインで使える特殊な記述の概要を以下に示します。

s:name			スクリプト内にローカルな変数

<SID>			スクリプトID。マップや関数をスクリプトローカルにする
			のに使う。

hasmapto()		スクリプトが提供している機能と同じマップが既に定義さ
			れているかどうかをチェックする関数

<Leader>		ユーザ側でプラグイン用のマップ割り当てに使う１文字目
			の文字を"mapleader"で指定できる。<Leader>は"mapleader"
			の値に置換される。

:map <unique>		既にその名前のマップ定義があれば警告を発する。

:noremap <script>	グローバルマップではなく、スクリプト内でローカルな
			マップを使う。

exists(":Cmd")		ユーザ定義コマンドが既にあるかどうかをチェックする。

==============================================================================
*41.12*	ファイルタイププラグインを書く	*write-filetype-plugin* *ftplugin*

ファイルタイププラグインはグローバルプラグインと似ています。違うのは現在の
バッファ専用のマップ定義やオプション設定が行える点です。ファイルタイププラグ
インがどのように使われるかについては|add-filetype-plugin|をご覧ください。

先に|41.10|節のグローバルプラグインをご覧ください。そこで説明してあることは全
てファイルタイププラグインにも適用されます。この節ではファイルタイププラグ
イン独自の機能について説明します。ファイルタイププラグインで最も違うのは現在
のバッファだけに影響を与えるという点です。


ロードの禁止
------------

多くの人々に使ってもらえるようなファイルタイププラグインを書くのであれば、
そのロードを禁止する方法が必要です。プラグインの先頭に次のような記述を追加し
てください。 >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

これは同じプラグインを同じバッファで２重ロード(これは":edit"コマンドをパラメ
タなしで実行した時に発生します)するのを避けるのにも使えます。

これでユーザは自分のファイルタイププラグインに次の一行を追加するだけで、デフォ
ルトプラグインのロードを完全に禁止することができます。 >

	let b:did_ftplugin = 1

これはファイルタイププラグインのディレクトリは'runtimepath'にある$VIMRUNTIME
よりも前に来なければなりません。

もしデフォルトプラグインを使いたいけれど、そのうちのひとつを無効にしたいのな
ら、違う設定をするスクリプトをこのように作ればよいのです。 >

	setlocal textwidth=70

こうして書いたファイルを"after"ディレクトリに入れておけば、"vim.vim"が全ての
ファイルタイププラグインをロードした後に実行されます|after-directory|。例えば
Unixなら"~/.vim/after/ftplugin/vim.vim"となります。デフォルトプラグインは
"b:did_ftplugin"をセットするので、つまり後で再読み込みしても何もしないのです。


オプション
----------

ファイルタイププラグインでは現在のバッファでのみオプション設定が有効となるよ
うに、次のコマンドを使うようにします。 >

	:setlocal

また、設定できるオプションはバッファにローカルなものに限ります。(どのオプ
ションがそうなのかはヘルプで確認してください) |:setlocal|コマンドを使ってグ
ローバルなオプションやウィンドウにローカルなオプションを設定しようとすると、
値は多くのバッファで変更されます。これはファイルタイププラグインがすべきこと
ではありません。

オプションがフラグリストや項目リストの場合、"+="や"-="を使って、既存の値を守
る考えましょう。ユーザが既に値を変更している可能性がある点に注意しましょう。
最初にデフォルト値に再設定しておき、それから変更するというのは良い方法です。
例を示しましょう。 >

	:setlocal formatoptions& formatoptions+=ro


マップ
------

カレントバッファでのみ動くマップを作るには次のコマンドを使います。 >

	:map <buffer>

これは上でも説明したように２段階に分けてマップを作る必要があります。ファイル
タイププラグインでの機能定義の方法を以下に示します。 >

	if !hasmapto('<Plug>JavaImport')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
	endif
	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>

|hasmapto()| はユーザが既に<Plub>JavaImportというマップを定義しているかどうか
を調べます。未定義ならファイルタイププラグインでデフォルトマップを定義します。
これは|<LocalLeader>|の文字で始まります。ユーザは<LocalLeader>キーを自分で定義
できます。これはマップの最初の１文字目となります。デフォルトではバックスラッ
シュキーになっています。
"<unique>"キーワードを使うと、そのマップが既に定義されている時や既存のマップに
上書きする時にエラーメッセージを出します。
|:noremap|はユーザが既に定義しているマップが防害するのを避けるのに使います。こ
のスクリプトで定義されているマップで<SID>で始まっているを再定義できるようにす
るために":noremap <script>"を使いたくなることもあるでしょう。

利用者にはファイルタイププラグインで定義しているマップを禁止できる仕組みを提供
しなければなりません。以下に"mail"ファイルタイプ用のプラグインでそれをどのよう
に実現しているかの例を示します。 >

	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote
	  endif
	  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
	endif

ここでは２つのグローバル変数を使っています。
  no_plugin_maps	全ファイルタイププラグインでのマップを禁止
  no_mail_maps		特定のファイルタイププラグインでのマップを禁止


ユーザ定義コマンド
------------------

特定のファイルタイプ用のユーザ定義コマンドを１つのバッファでのみ実行するには
|:command|実行時に"-buffer" パラメタを用います。例えば次のように使います。 >

	:command -buffer  Make  make %:r.s


変数
----

ファイルタイププラグインは合致するファイルタイプの各バッファ毎に読み込みます。
スクリプト内にローカルな(|s:var|形式の)変数は全バッファで共有されます。バッ
ファ内にローカルな(|b:var|形式の)変数を使えば、バッファ毎に独立した変数が使
用できます。


関数
----

関数の定義は１回だけ行えば、それ以上は必要ありません。しかし上でも述べたよう
に、ファイルタイププラグインは該当するタイプのファイルが開く毎に読み込まれま
す。ですから関数が１度だけ定義されるようにこのような構造としておく必要があり
ます。 >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

アンドゥ						*undo_ftplugin*
--------

ユーザーが ":setfiletype xyz" としたとき、それ以前のファイルタイプの効果は無
効になるべきです。ファイルタイププラグインの設定を無効にするために
b:undo_ftplugin 変数を設定してください。例: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"

":setlocal"を使いオプションの名前の後に"<"を使うとそのオプションをグローバル
の値でリセットします。オプションをリセットするにはこの方法が一番です。

これにはコマンド行の連結を可能にするために'cpoptions'から"C"フラグを取り除く
ことが必要です。上述の|use-cpo-save|を参照してください。

ファイル名
----------

ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければ
なりません|ftplugin-name|。次の三つのうちのどれかにしてください。

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff"はファイルタイプ名。"foo"と"bar"は責任者の名前です。


まとめ							*ftplugin-special*
------

ファイルタイププラグインの特徴をまとめましょう。

<LocalLeader>		"maplocalleader"の値となります。これを使うとファイル
			タイププラグインのマップの最初に入力する文字がこの値
			に置き換わります。

:map <buffer>		バッファローカルなマップ定義

:noremap <script>	このスクリプトで定義しているうち、<SID>で始まっている
			マップだけを再定義する。

:setlocal		バッファローカルなオプション値の設定を行う。

:command -buffer	バッファローカルなユーザ定義コマンドを定義する。

exists("*s:Func")	関数が既に定義済かどうかをチェック

全プラグインで使える特別な項目については|plugin-special|も併せてご覧ください。

==============================================================================
*41.13*	コンパイラプラグインを書く		*write-compiler-plugin*

コンパイラプラグインでは特定のコンパイラを使うためのオプション設定ができます。
この呼び出しは|:compiler|コマンドで行います。この中心となるのは'errorformat'
と'makeprg'オプションの設定です。

次のようにすれば簡単に実例を見ることができます。このコマンドでデフォルトのコン
パイラプラグインを全て見ることができるでしょう。 >

	:next $VIMRUNTIME/compiler/*.vim

|:next|を使って次のファイルに移ってください。

これらのファイルのための特別な仕組みが２つあります。１つはデフォルトファイルの
ルールを変更したり追加したりできる仕組です。デフォルトファイルは次のようになっ
ています。 >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

コンパイラファイルを書いて、個人用のランタイムディレクトリ(例えばUnixであれ
ば ~/vim/compiler)に置く時に"current_compiler"という変数を設定しておいて、デ
フォルトファイルの設定をスキップさせることができます。

２つめの仕組みは、":set"を使う":compiler!"と":setlocal"を使う":compiler"です。
Vimはこのために":CompilerSet"というユーザーコマンドを定義します。しかしふ
るいVimではそうではないので、あなたのプラグインで定義してください。次に例を示
します。 >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the dfault 'errorformat'
  CompilerSet makeprg=nmake

vimの配布用やステム全体のランタイムディレクトリに置くようなコンパイラプラグ
インを書くのであれば、上で書いたような仕組を作っておいてください。つまり、
"current_compiler"がユーザプラグインで既に設定されていれば、何もしないように
するわけです。

デフォルトプラグインのルールを変更するようなコンパイラプラグインを書くのであ
れば、"current_compiler"をチェックしないようにしてください。このプラグインは
最後にロードされるように、つまり'runtimepath'のディレクトリリストの最後に置
くようにすべきです。例えば、Unixでは~/.vim/after/compilerなどが使えるでしょ
う。

==============================================================================
*41.14*	高速に読み込まれるプラグインを書く	write-plugin-quickload*

プラグインが成長し、非常に長くなることがあります。起動時の遅延が顕著になり、と
ても全てのプラグインを使っていられなくなることがあります。そのときは、クイック
ロードプラグインを使うときです。

基本的な考えは、プラグインを2回に分けて読み込むことです。1回目は、機能を提供す
るユーザー定義コマンドとマッピングを定義します。2回目は定義された機能を実装す
る関数を読み込みます。

スクリプトを2回読み込むことがクイックロードだというと驚かれるかもしれません。
この手法の意味は、1回目は高速に読み込み、スクリプトの重い部分は2回目に後回しに
するということです。2回目の読み込みは、ユーザが実際にその機能を使用するときだ
け発生します。あなたがその機能をいつも使っているのなら、これはやはり遅くなって
しまうでしょう。

Note Vim 7以降では代わりの方法があります。|41.15|で説明されている|autoload|機
能を使うことです。

以下の例は、これをどうやって行うかを説明しています: >

	" クイックロードのデモ用のグローバルプラグイン
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read 機能をここに書く
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write 機能をここに書く
	endfunction

このスクリプトが最初に読み込まれたとき、"s:did_load"は設定されていません。
"if"と"endif"の間のコマンドが実行されます。この部分はコマンド|:finish|によって
終了し、スクリプトの残りの部分は実行されません。

2回目に読み込まれたときは"s:did_load"が存在し、"endif"以降のコマンドが実行され
ます。この部分では(長くなる可能性のある)BufNetRead()とBufNetWrite()関数を定義
します。

このスクリプトをプラグインディレクトリに置くと、Vimの起動時に実行されます。そ
のときの流れは次のようになります:

1. 起動時、このスクリプトが読み込まれたときに"BNRead"コマンドが定義され、<F19>
   キーにマッピングされる。自動コマンド|FuncUndefined|が定義される。コマンド
   ":finish"によりこのスクリプトが終了する。

2. ユーザがコマンドBNReadを入力する、または<F19>キーを押す。関数BufNetRead()ま
   たはBufNetWrite()が呼ばれる。

3. Vimはこの関数を見つけることができず、自動コマンドイベント|FuncUndefined|が
   発生する。呼ばれた関数の名前がパターン"BufNet*"がマッチするので、コマンド
   "source fname"が実行される。ここで"<sname>"(|expand()|を参照)が展開されるの
   で、スクリプトがどこにあろうとも、fnameはこのスクリプトの名前になる。

4. このスクリプトが再び読み込まれ、変数"s:did_load"が存在するので、関数が定義
   される。

読み込まれる関数の名前が、自動コマンド|FuncUndefined|におけるパターンにマッチ
しなければならないことに注意してください。他のどのプラグインも、このパターンに
マッチする関数を定義していないことを確認しなければなりません。

==============================================================================
*41.15*	ライブラリスクリプトを書く			*write-library-script*

ある種の機能はいろいろな場所で必要になります。それが2,3行以上になる場合は、そ
れを１つのスクリプトにして、他のスクリプトから利用できるようにするとよいでしょ
う。このようなスクリプトのことをライブラリスクリプトと呼びます。

手動でライブラリスクリプトを読み込むことは可能ですが、すでに読み込まれている場
合は二重に読み込むのを防がねばなりません。それには関数|exists()|を使います。
例: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)

ここで、あなたは'runtimepath'にあるディレクトリのどこかの
"library/mylibscript.vim"でMyLibFunction()が定義されていることを知っていなけれ
ばなりません。

これをより簡単にするために、Vimにはautoloadの機構が備わっています。これを使う
とこの例は次のようになります: >

	call mylib#myfunction(arg)

この方がずっと簡単でしょう？Vimはこの関数名を認識し、それがまだ定義されていな
い場合は"autoload/mylib.vim"を'runtimepath'から検索します。そのスクリプトは関
数"mylib#myfunction()"を定義していなければなりません。

このmylib.vimに他の関数を入れることもできます。ライブラリスクリプト中の関数を
自由に構成することができます。しかし関数名の'#'より前の部分はそのスクリプトの
名前に一致するようにしなければなりません。そうしないとVimはどのスクリプトを読
み込んだらいいかわからなくなってしまいます。

これに熱狂してライブラリスクリプトをたくさん書くと、サブディレクトリを使いたく
なるかもしれません。例: >

	call netlib#ftp#read('somefile')

Unixでは、このライブラリスクリプトを次の場所に置けます: >

	~/.vim/autoload/netlib/ftp.vim

この関数は次のように定義します: >

	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction

関数定義に使われている名前が、それを使っているときの名前とまったく同じであるこ
とに注意してください。そして最後の'#'より前の部分がサブディレクトリとスクリプ
トの名前に対応しています。

これと同じ機構を変数にも使用することができます: >

	let weekdays = dutch#weekdays

これはスクリプト"autoload/dutch.vim"を読み込みます。そのスクリプトは次のような
コードを含んでいるはずです: >

	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

より詳しくは|autoload|を参照してください。

==============================================================================
*41.16*	Vimスクリプトを配布する			*distribute-script*

VimのユーザはVimのウェブサイトhttp://www.vim.orgでスクリプトを探すでしょう。他
の人の役に立つものを作ったら、それを共有しましょう。

Vimスクリプトはどんなシステム上でも使えます。tarやgzipコマンドは存在しないかも
しれません。ファイルをまとめたり圧縮したいときは、"zip"コマンドが推奨されてい
ます。

最大限の移植性のために、スクリプトをアーカイブするのにVim自身を使いましょう。
それはVimballユーティリティによってできます。|vimball|を参照。

自動更新をできるように1行を加えておくとよいでしょう。|glvs-plugins|を参照。

==============================================================================

Next chapter: |usr_42.txt|  新しいメニューの追加

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
